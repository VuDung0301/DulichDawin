const Tour = require('../models/Tour');
const { upload, getRelativePath, deleteFile } = require('../utils/fileHandler');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

/**
 * @desc    L·∫•y t·∫•t c·∫£ c√°c tour
 * @route   GET /api/tours
 * @access  Public
 */
exports.getAllTours = async (req, res, next) => {
  try {
    console.log('üéØ getAllTours called with query:', req.query);
    
    // Build query
    const queryObj = { ...req.query };
    const excludedFields = ['page', 'sort', 'limit', 'fields', 'keyword', 'destination', 'departure', 'duration', 'priceRange', 'rating', 'date', 'category'];
    excludedFields.forEach(el => delete queryObj[el]);

    // Advanced filtering
    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, match => `$${match}`);
    
    let query = Tour.find(JSON.parse(queryStr));

    // L·ªçc theo ƒëi·ªÉm ƒë·∫øn
    if (req.query.destination) {
      console.log('üó∫Ô∏è Filtering by destination:', req.query.destination);
      query = query.find({
        $or: [
          { name: { $regex: req.query.destination, $options: 'i' } },
          { description: { $regex: req.query.destination, $options: 'i' } },
          { 'startLocation.description': { $regex: req.query.destination, $options: 'i' } },
          { 'locations.description': { $regex: req.query.destination, $options: 'i' } }
        ]
      });
    }

    // L·ªçc theo ƒëi·ªÉm xu·∫•t ph√°t
    if (req.query.departure) {
      console.log('üöè Filtering by departure:', req.query.departure);
      query = query.find({
        'startLocation.description': { $regex: req.query.departure, $options: 'i' }
      });
    }

    // L·ªçc theo th·ªùi gian
    if (req.query.duration) {
      console.log('‚è±Ô∏è Filtering by duration:', req.query.duration);
      if (req.query.duration === '1-3') {
        query = query.find({ duration: { $gte: 1, $lte: 3 } });
      } else if (req.query.duration === '4-7') {
        query = query.find({ duration: { $gte: 4, $lte: 7 } });
      } else if (req.query.duration === '8-14') {
        query = query.find({ duration: { $gte: 8, $lte: 14 } });
      } else if (req.query.duration === '15+') {
        query = query.find({ duration: { $gte: 15 } });
      }
    }

    // L·ªçc theo kho·∫£ng gi√°
    if (req.query.priceRange) {
      console.log('üí∞ Filtering by priceRange:', req.query.priceRange);
      if (req.query.priceRange === '0-2000000') {
        query = query.find({ price: { $gte: 0, $lte: 2000000 } });
      } else if (req.query.priceRange === '2000000-5000000') {
        query = query.find({ price: { $gte: 2000000, $lte: 5000000 } });
      } else if (req.query.priceRange === '5000000-10000000') {
        query = query.find({ price: { $gte: 5000000, $lte: 10000000 } });
      } else if (req.query.priceRange === '10000000+') {
        query = query.find({ price: { $gte: 10000000 } });
      }
    }

    // L·ªçc theo ƒë√°nh gi√°
    if (req.query.rating) {
      const rating = parseInt(req.query.rating);
      query = query.find({ ratingsAverage: { $gte: rating } });
    }

    // L·ªçc theo ng√†y kh·ªüi h√†nh
    if (req.query.date) {
      const searchDate = new Date(req.query.date);
      query = query.find({ 
        startDates: { 
          $elemMatch: { 
            $gte: searchDate 
          } 
        } 
      });
    }

    // L·ªçc theo danh m·ª•c (n·∫øu c√≥ field category trong model)
    if (req.query.category) {
      // T√¨m ki·∫øm theo t√™n ho·∫∑c m√¥ t·∫£ ƒë·ªÉ match v·ªõi category
      const categoryMap = {
        'adventure': ['m·∫°o hi·ªÉm', 'phi√™u l∆∞u', 'adventure'],
        'cultural': ['vƒÉn h√≥a', 'l·ªãch s·ª≠', 'cultural', 'heritage'],
        'beach': ['bi·ªÉn', 'beach', 'coastal'],
        'mountain': ['n√∫i', 'mountain', 'highland'],
        'food': ['·∫©m th·ª±c', 'food', 'culinary'],
        'eco': ['sinh th√°i', 'eco', 'nature']
      };
      
      const keywords = categoryMap[req.query.category] || [req.query.category];
      const regexPattern = keywords.join('|');
      
      query = query.find({
        $or: [
          { name: { $regex: regexPattern, $options: 'i' } },
          { description: { $regex: regexPattern, $options: 'i' } }
        ]
      });
    }

    // T√¨m ki·∫øm theo t·ª´ kh√≥a n·∫øu c√≥
    if (req.query.keyword) {
      query = query.find({
        $or: [
          { name: { $regex: req.query.keyword, $options: 'i' } },
          { description: { $regex: req.query.keyword, $options: 'i' } }
        ]
      });
    }

    // Sorting
    if (req.query.sort) {
      const sortBy = req.query.sort.split(',').join(' ');
      query = query.sort(sortBy);
    } else {
      query = query.sort('-createdAt');
    }

    // Field limiting
    if (req.query.fields) {
      const fields = req.query.fields.split(',').join(' ');
      query = query.select(fields);
    } else {
      query = query.select('-__v');
    }

    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;

    query = query.skip(skip).limit(limit);

    // Execute query
    const tours = await query;
    console.log('üìä Tours found:', tours.length);
    
    // Get total count for pagination - s·ª≠ d·ª•ng c√πng ƒëi·ªÅu ki·ªán filter
    let countQuery = Tour.find(JSON.parse(queryStr));
    
    // Apply same filters for count
    if (req.query.destination) {
      countQuery = countQuery.find({
        $or: [
          { name: { $regex: req.query.destination, $options: 'i' } },
          { description: { $regex: req.query.destination, $options: 'i' } },
          { 'startLocation.description': { $regex: req.query.destination, $options: 'i' } },
          { 'locations.description': { $regex: req.query.destination, $options: 'i' } }
        ]
      });
    }

    if (req.query.departure) {
      countQuery = countQuery.find({
        'startLocation.description': { $regex: req.query.departure, $options: 'i' }
      });
    }

    if (req.query.duration) {
      if (req.query.duration === '1-3') {
        countQuery = countQuery.find({ duration: { $gte: 1, $lte: 3 } });
      } else if (req.query.duration === '4-7') {
        countQuery = countQuery.find({ duration: { $gte: 4, $lte: 7 } });
      } else if (req.query.duration === '8-14') {
        countQuery = countQuery.find({ duration: { $gte: 8, $lte: 14 } });
      } else if (req.query.duration === '15+') {
        countQuery = countQuery.find({ duration: { $gte: 15 } });
      }
    }

    if (req.query.priceRange) {
      if (req.query.priceRange === '0-2000000') {
        countQuery = countQuery.find({ price: { $gte: 0, $lte: 2000000 } });
      } else if (req.query.priceRange === '2000000-5000000') {
        countQuery = countQuery.find({ price: { $gte: 2000000, $lte: 5000000 } });
      } else if (req.query.priceRange === '5000000-10000000') {
        countQuery = countQuery.find({ price: { $gte: 5000000, $lte: 10000000 } });
      } else if (req.query.priceRange === '10000000+') {
        countQuery = countQuery.find({ price: { $gte: 10000000 } });
      }
    }

    if (req.query.rating) {
      const rating = parseInt(req.query.rating);
      countQuery = countQuery.find({ ratingsAverage: { $gte: rating } });
    }

    if (req.query.date) {
      const searchDate = new Date(req.query.date);
      countQuery = countQuery.find({ 
        startDates: { 
          $elemMatch: { 
            $gte: searchDate 
          } 
        } 
      });
    }

    if (req.query.category) {
      const categoryMap = {
        'adventure': ['m·∫°o hi·ªÉm', 'phi√™u l∆∞u', 'adventure'],
        'cultural': ['vƒÉn h√≥a', 'l·ªãch s·ª≠', 'cultural', 'heritage'],
        'beach': ['bi·ªÉn', 'beach', 'coastal'],
        'mountain': ['n√∫i', 'mountain', 'highland'],
        'food': ['·∫©m th·ª±c', 'food', 'culinary'],
        'eco': ['sinh th√°i', 'eco', 'nature']
      };
      
      const keywords = categoryMap[req.query.category] || [req.query.category];
      const regexPattern = keywords.join('|');
      
      countQuery = countQuery.find({
        $or: [
          { name: { $regex: regexPattern, $options: 'i' } },
          { description: { $regex: regexPattern, $options: 'i' } }
        ]
      });
    }

    if (req.query.keyword) {
      countQuery = countQuery.find({
        $or: [
          { name: { $regex: req.query.keyword, $options: 'i' } },
          { description: { $regex: req.query.keyword, $options: 'i' } }
        ]
      });
    }

    const total = await countQuery.countDocuments();

    // ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi ph√π h·ª£p v·ªõi frontend admin
    res.status(200).json({
      success: true,
      data: {
        tours: tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total // Th√™m tr∆∞·ªùng n√†y ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi frontend
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y chi ti·∫øt m·ªôt tour
 * @route   GET /api/tours/:id
 * @access  Public
 */
exports.getTour = async (req, res, next) => {
  try {
    const tour = await Tour.findById(req.params.id).populate({
      path: 'reviews',
      select: 'review rating user'
    });

    if (!tour) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y tour'
      });
    }

    res.status(200).json({
      success: true,
      data: tour
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    T·∫°o tour m·ªõi v·ªõi h√¨nh ·∫£nh
 * @route   POST /api/tours
 * @access  Private/Admin
 */
exports.createTour = async (req, res, next) => {
  // C·∫•u h√¨nh multer cho upload nhi·ªÅu file
  const uploadMultiple = upload.fields([
    { name: 'coverImageFile', maxCount: 1 },
    { name: 'imagesFiles', maxCount: 10 },
    { name: 'itineraryImagesFiles', maxCount: 20 } // Th√™m field m·ªõi cho ·∫£nh l·ªãch tr√¨nh
  ]);

  uploadMultiple(req, res, async (err) => {
    if (err) {
      if (err instanceof multer.MulterError) {
        // L·ªói t·ª´ multer
        return res.status(400).json({
          success: false,
          message: `L·ªói upload: ${err.message}`
        });
      } else {
        // L·ªói kh√¥ng x√°c ƒë·ªãnh
        return res.status(500).json({
          success: false,
          message: `L·ªói upload: ${err.message}`
        });
      }
    }

    try {
      // D·ªØ li·ªáu tour t·ª´ form
      const tourData = { ...req.body };
      
      // Ki·ªÉm tra gi√° v√† gi√° gi·∫£m
      if (tourData.price && tourData.priceDiscount) {
        const price = Number(tourData.price);
        const priceDiscount = Number(tourData.priceDiscount);
        
        if (priceDiscount >= price) {
          return res.status(400).json({
            success: false,
            message: 'Gi√° khuy·∫øn m√£i ph·∫£i nh·ªè h∆°n gi√° g·ªëc'
          });
        }
        
        // ƒê·∫£m b·∫£o d·ªØ li·ªáu l√† ki·ªÉu s·ªë
        tourData.price = price;
        tourData.priceDiscount = priceDiscount;
      }

      // X·ª≠ l√Ω ·∫£nh ƒë·∫°i di·ªán
      if (req.files.coverImageFile && req.files.coverImageFile.length > 0) {
        const file = req.files.coverImageFile[0];
        const fileType = 'common';
        const relativePath = getRelativePath(fileType, file.filename);
        const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
        
        tourData.coverImage = fileUrl;
      } else if (req.body.coverImage) {
        // Gi·ªØ nguy√™n ·∫£nh hi·ªán t·∫°i n·∫øu kh√¥ng upload ·∫£nh m·ªõi
        tourData.coverImage = req.body.coverImage;
      } else {
        return res.status(400).json({
          success: false,
          message: '·∫¢nh ƒë·∫°i di·ªán l√† b·∫Øt bu·ªôc'
        });
      }

      // X·ª≠ l√Ω ·∫£nh b·ªï sung
      const tourImages = [];
      
      // Th√™m c√°c URL ·∫£nh hi·ªán c√≥ (n·∫øu c√≥)
      if (req.body.images) {
        try {
          // X·ª≠ l√Ω images ƒë∆∞·ª£c g·ª≠i t·ª´ client
          let existingImages = [];
          
          if (typeof req.body.images === 'string') {
            try {
              // Th·ª≠ parse JSON t·ª´ string
              const parsedImages = JSON.parse(req.body.images);
              if (Array.isArray(parsedImages)) {
                existingImages = parsedImages;
                console.log(`Parsed images t·ª´ string JSON, c√≥ ${existingImages.length} ·∫£nh`);
              } else {
                console.log('images sau khi parse kh√¥ng ph·∫£i array:', parsedImages);
              }
            } catch (e) {
              console.error('L·ªói khi parse images JSON:', e);
            }
          } else if (Array.isArray(req.body.images)) {
            existingImages = req.body.images;
            console.log(`ƒê√£ nh·∫≠n m·∫£ng images tr·ª±c ti·∫øp v·ªõi ${existingImages.length} ·∫£nh`);
          } else {
            console.log('Ki·ªÉu d·ªØ li·ªáu images kh√¥ng h·ªó tr·ª£:', typeof req.body.images);
          }
          
          tourImages.push(...existingImages);
          console.log(`ƒê√£ th√™m ${existingImages.length} ·∫£nh hi·ªán c√≥ v√†o gallery`);
        } catch (error) {
          console.error('L·ªói khi x·ª≠ l√Ω ·∫£nh hi·ªán c√≥:', error);
        }
      }
      
      // Th√™m c√°c file ·∫£nh m·ªõi
      if (req.files.imagesFiles && req.files.imagesFiles.length > 0) {
        const fileType = 'common';
        
        req.files.imagesFiles.forEach(file => {
          const relativePath = getRelativePath(fileType, file.filename);
          const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
          tourImages.push(fileUrl);
        });
        console.log(`Th√™m ${req.files.imagesFiles.length} ·∫£nh m·ªõi v√†o gallery`);
      }
      
      tourData.images = tourImages;
      console.log(`T·ªïng c·ªông ${tourData.images.length} ·∫£nh trong gallery sau khi x·ª≠ l√Ω`);

      // X·ª≠ l√Ω c√°c tr∆∞·ªùng JSON
      if (tourData.locations && typeof tourData.locations === 'string') {
        try {
          tourData.locations = JSON.parse(tourData.locations);
        } catch (e) {
          console.error('L·ªói khi parse locations:', e);
        }
      }
      
      // X·ª≠ l√Ω itinerary v√† th√™m ·∫£nh cho m·ªói ng√†y n·∫øu c√≥
      if (tourData.itinerary && typeof tourData.itinerary === 'string') {
        try {
          let itinerary = JSON.parse(tourData.itinerary);
          
          // Chuy·ªÉn ƒë·ªïi tr∆∞·ªùng h·ª£p truy·ªÅn blob URLs trong itinerary
          if (Array.isArray(itinerary)) {
            itinerary = itinerary.map(day => {
              if (day.image && day.image.startsWith('blob:')) {
                return {
                  ...day,
                  image: '' // Lo·∫°i b·ªè blob URL kh√¥ng h·ª£p l·ªá
                };
              }
              return day;
            });
          }
          
          // Ki·ªÉm tra v√† th√™m ·∫£nh cho m·ªói ng√†y trong l·ªãch tr√¨nh
          if (req.files.itineraryImagesFiles && req.files.itineraryImagesFiles.length > 0) {
            const fileType = 'common';
            const itineraryImageMap = {};
            
            // X·ª≠ l√Ω t√™n file ƒë·ªÉ x√°c ƒë·ªãnh ng√†y
            // ƒê·ªãnh d·∫°ng t√™n file mong ƒë·ª£i: day-1.jpg, day-2.jpg, ...
            req.files.itineraryImagesFiles.forEach(file => {
              const match = file.originalname.match(/day-(\d+)/i);
              if (match && match[1]) {
                const dayNumber = parseInt(match[1]);
                const relativePath = getRelativePath(fileType, file.filename);
                const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
                itineraryImageMap[dayNumber] = fileUrl;
                console.log(`ƒê√£ t√¨m th·∫•y ·∫£nh cho ng√†y ${dayNumber}: ${fileUrl}`);
              }
            });
            
            // Gi·ªØ l·∫°i ·∫£nh c≈© cho c√°c ng√†y kh√¥ng c√≥ ·∫£nh m·ªõi
            const currentItineraryMap = {};
            
            // G√°n ·∫£nh cho m·ªói ng√†y trong l·ªãch tr√¨nh
            itinerary = itinerary.map(day => {
              // Ki·ªÉm tra xem c√≥ ·∫£nh m·ªõi hay kh√¥ng
              const image = itineraryImageMap[day.day] || day.image;
              
              // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ·∫£nh l√† blob URL
              if (image && image.startsWith('blob:')) {
                return {
                  ...day,
                  image: '' // B·ªè blob URL, s·∫Ω th√™m ·∫£nh th·ª±c t·∫ø sau
                };
              }
              
              return {
                ...day,
                image
              };
            });
          }
          
          tourData.itinerary = itinerary;
        } catch (e) {
          console.error('L·ªói khi parse itinerary:', e);
          // Kh√¥ng d·ª´ng l·∫°i ·ªü ƒë√¢y, ti·∫øp t·ª•c v·ªõi c√°c tr∆∞·ªùng kh√°c
        }
      } else {
        // N·∫øu itinerary l√† m·ªôt m·∫£ng ƒë·ªëi t∆∞·ª£ng (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ph√≠a client)
        if (req.body.itinerary && typeof req.body.itinerary === 'object') {
          tourData.itinerary = req.body.itinerary;
        }
      }
      
      if (tourData.startLocation && typeof tourData.startLocation === 'string') {
        try {
          tourData.startLocation = JSON.parse(tourData.startLocation);
        } catch (e) {
          console.error('L·ªói khi parse startLocation:', e);
        }
      }
      
      if (tourData.guides && typeof tourData.guides === 'string') {
        try {
          tourData.guides = JSON.parse(tourData.guides);
        } catch (e) {
          console.error('L·ªói khi parse guides:', e);
        }
      }
      
      if (tourData.includes && typeof tourData.includes === 'string') {
        try {
          tourData.includes = JSON.parse(tourData.includes);
        } catch (e) {
          console.error('L·ªói khi parse includes:', e);
        }
      }
      
      if (tourData.excludes && typeof tourData.excludes === 'string') {
        try {
          tourData.excludes = JSON.parse(tourData.excludes);
        } catch (e) {
          console.error('L·ªói khi parse excludes:', e);
        }
      }
      
      if (tourData.startDates && typeof tourData.startDates === 'string') {
        try {
          tourData.startDates = JSON.parse(tourData.startDates);
        } catch (e) {
          console.error('L·ªói khi parse startDates:', e);
        }
      }

      // T·∫°o tour m·ªõi
      const newTour = await Tour.create(tourData);

      res.status(201).json({
        success: true,
        data: newTour
      });
    } catch (error) {
      console.error('L·ªói khi t·∫°o tour:', error);
      
      res.status(400).json({
        success: false,
        message: error.message
      });
    }
  });
};

/**
 * @desc    C·∫≠p nh·∫≠t tour
 * @route   PUT /api/tours/:id
 * @access  Private/Admin
 */
exports.updateTour = async (req, res, next) => {
  // C·∫•u h√¨nh multer cho upload nhi·ªÅu file
  const uploadMultiple = upload.fields([
    { name: 'coverImageFile', maxCount: 1 },
    { name: 'imagesFiles', maxCount: 10 },
    { name: 'itineraryImagesFiles', maxCount: 20 } // Th√™m field m·ªõi cho ·∫£nh l·ªãch tr√¨nh
  ]);

  uploadMultiple(req, res, async (err) => {
    if (err) {
      if (err instanceof multer.MulterError) {
        // L·ªói t·ª´ multer
        return res.status(400).json({
          success: false,
          message: `L·ªói upload: ${err.message}`
        });
      } else {
        // L·ªói kh√¥ng x√°c ƒë·ªãnh
        return res.status(500).json({
          success: false,
          message: `L·ªói upload: ${err.message}`
        });
      }
    }

    try {
      // T√¨m tour hi·ªán t·∫°i
      const tour = await Tour.findById(req.params.id);
      if (!tour) {
        return res.status(404).json({
          success: false,
          message: 'Kh√¥ng t√¨m th·∫•y tour'
        });
      }

      // D·ªØ li·ªáu tour t·ª´ form
      const tourData = { ...req.body };

      // Ki·ªÉm tra gi√° v√† gi√° gi·∫£m
      if (tourData.price && tourData.priceDiscount) {
        const price = Number(tourData.price);
        const priceDiscount = Number(tourData.priceDiscount);
        
        if (priceDiscount >= price) {
          return res.status(400).json({
            success: false,
            message: 'Gi√° khuy·∫øn m√£i ph·∫£i nh·ªè h∆°n gi√° g·ªëc'
          });
        }
        
        // ƒê·∫£m b·∫£o d·ªØ li·ªáu l√† ki·ªÉu s·ªë
        tourData.price = price;
        tourData.priceDiscount = priceDiscount;
      }

      // X·ª≠ l√Ω ·∫£nh ƒë·∫°i di·ªán
      if (req.files.coverImageFile && req.files.coverImageFile.length > 0) {
        const file = req.files.coverImageFile[0];
        const fileType = 'common';
        const relativePath = getRelativePath(fileType, file.filename);
        const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
        
        // X√≥a ·∫£nh c≈© n·∫øu c√≥
        if (tour.coverImage) {
          try {
            const oldRelativePath = tour.coverImage.split('/uploads/')[1];
            if (oldRelativePath) {
              await deleteFile(oldRelativePath);
            }
          } catch (error) {
            console.error('L·ªói khi x√≥a ·∫£nh c≈©:', error);
          }
        }
        
        tourData.coverImage = fileUrl;
      } else if (req.body.coverImage) {
        // Gi·ªØ nguy√™n ·∫£nh hi·ªán t·∫°i n·∫øu kh√¥ng upload ·∫£nh m·ªõi
        tourData.coverImage = req.body.coverImage;
      }

      // X·ª≠ l√Ω gallery
      let tourImages = [];
      
      // X·ª≠ l√Ω c√°c ·∫£nh hi·ªán c√≥
      if (req.body.images) {
        try {
          // X·ª≠ l√Ω images ƒë∆∞·ª£c g·ª≠i t·ª´ client
          let existingImages = [];
          
          if (typeof req.body.images === 'string') {
            try {
              // Th·ª≠ parse JSON t·ª´ string
              const parsedImages = JSON.parse(req.body.images);
              if (Array.isArray(parsedImages)) {
                existingImages = parsedImages;
                console.log(`Parsed images t·ª´ string JSON, c√≥ ${existingImages.length} ·∫£nh`);
              } else {
                console.log('images sau khi parse kh√¥ng ph·∫£i array:', parsedImages);
              }
            } catch (e) {
              console.error('L·ªói khi parse images JSON:', e);
            }
          } else if (Array.isArray(req.body.images)) {
            existingImages = req.body.images;
            console.log(`ƒê√£ nh·∫≠n m·∫£ng images tr·ª±c ti·∫øp v·ªõi ${existingImages.length} ·∫£nh`);
          } else {
            console.log('Ki·ªÉu d·ªØ li·ªáu images kh√¥ng h·ªó tr·ª£:', typeof req.body.images);
          }
          
          // X√≥a c√°c ·∫£nh kh√¥ng c√≤n trong danh s√°ch
          const imagesToKeep = new Set(existingImages);
          const imagesToDelete = tour.images.filter(img => !imagesToKeep.has(img));
          
          for (const imgUrl of imagesToDelete) {
            try {
              const relativePath = imgUrl.split('/uploads/')[1];
              if (relativePath) {
                await deleteFile(relativePath);
                console.log(`ƒê√£ x√≥a ·∫£nh: ${imgUrl}`);
              }
            } catch (error) {
              console.error(`L·ªói khi x√≥a ·∫£nh ${imgUrl}:`, error);
            }
          }
          
          tourImages = [...existingImages];
        } catch (error) {
          console.error('L·ªói khi x·ª≠ l√Ω danh s√°ch ·∫£nh:', error);
          tourImages = [...tour.images]; // Gi·ªØ nguy√™n ·∫£nh hi·ªán t·∫°i n·∫øu c√≥ l·ªói
        }
      } else {
        tourImages = [...tour.images]; // Gi·ªØ nguy√™n ·∫£nh hi·ªán t·∫°i n·∫øu kh√¥ng c√≥ th√¥ng tin m·ªõi
      }
      
      // Th√™m c√°c file ·∫£nh m·ªõi
      if (req.files.imagesFiles && req.files.imagesFiles.length > 0) {
        const fileType = 'common';
        
        req.files.imagesFiles.forEach(file => {
          const relativePath = getRelativePath(fileType, file.filename);
          const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
          tourImages.push(fileUrl);
        });
        console.log(`Th√™m ${req.files.imagesFiles.length} ·∫£nh m·ªõi v√†o gallery`);
      }
      
      tourData.images = tourImages;
      console.log(`T·ªïng c·ªông ${tourData.images.length} ·∫£nh trong gallery sau khi x·ª≠ l√Ω`);

      // X·ª≠ l√Ω c√°c tr∆∞·ªùng JSON
      if (tourData.locations && typeof tourData.locations === 'string') {
        try {
          tourData.locations = JSON.parse(tourData.locations);
        } catch (e) {
          console.error('L·ªói khi parse locations:', e);
        }
      }
      
      // X·ª≠ l√Ω itinerary v√† th√™m ·∫£nh cho m·ªói ng√†y n·∫øu c√≥
      if (tourData.itinerary && typeof tourData.itinerary === 'string') {
        try {
          let itinerary = JSON.parse(tourData.itinerary);
          
          // Chuy·ªÉn ƒë·ªïi tr∆∞·ªùng h·ª£p truy·ªÅn blob URLs trong itinerary
          if (Array.isArray(itinerary)) {
            itinerary = itinerary.map(day => {
              if (day.image && day.image.startsWith('blob:')) {
                return {
                  ...day,
                  image: '' // Lo·∫°i b·ªè blob URL kh√¥ng h·ª£p l·ªá
                };
              }
              return day;
            });
          }
          
          // Ki·ªÉm tra v√† th√™m ·∫£nh cho m·ªói ng√†y trong l·ªãch tr√¨nh
          if (req.files.itineraryImagesFiles && req.files.itineraryImagesFiles.length > 0) {
            const fileType = 'common';
            const itineraryImageMap = {};
            
            // X·ª≠ l√Ω t√™n file ƒë·ªÉ x√°c ƒë·ªãnh ng√†y
            // ƒê·ªãnh d·∫°ng t√™n file mong ƒë·ª£i: day-1.jpg, day-2.jpg, ...
            req.files.itineraryImagesFiles.forEach(file => {
              const match = file.originalname.match(/day-(\d+)/i);
              if (match && match[1]) {
                const dayNumber = parseInt(match[1]);
                const relativePath = getRelativePath(fileType, file.filename);
                const fileUrl = `${req.protocol}://${req.get('host')}/uploads/${relativePath}`;
                itineraryImageMap[dayNumber] = fileUrl;
                console.log(`ƒê√£ t√¨m th·∫•y ·∫£nh cho ng√†y ${dayNumber}: ${fileUrl}`);
              }
            });
            
            // Gi·ªØ l·∫°i ·∫£nh c≈© cho c√°c ng√†y kh√¥ng c√≥ ·∫£nh m·ªõi
            const currentItineraryMap = {};
            
            // G√°n ·∫£nh cho m·ªói ng√†y trong l·ªãch tr√¨nh
            itinerary = itinerary.map(day => {
              // Ki·ªÉm tra xem c√≥ ·∫£nh m·ªõi hay kh√¥ng
              const image = itineraryImageMap[day.day] || day.image;
              
              // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ·∫£nh l√† blob URL
              if (image && image.startsWith('blob:')) {
                return {
                  ...day,
                  image: '' // B·ªè blob URL, s·∫Ω th√™m ·∫£nh th·ª±c t·∫ø sau
                };
              }
              
              return {
                ...day,
                image
              };
            });
          }
          
          tourData.itinerary = itinerary;
        } catch (e) {
          console.error('L·ªói khi parse itinerary:', e);
          // Kh√¥ng d·ª´ng l·∫°i ·ªü ƒë√¢y, ti·∫øp t·ª•c v·ªõi c√°c tr∆∞·ªùng kh√°c
        }
      } else {
        // N·∫øu itinerary l√† m·ªôt m·∫£ng ƒë·ªëi t∆∞·ª£ng (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü ph√≠a client)
        if (req.body.itinerary && typeof req.body.itinerary === 'object') {
          tourData.itinerary = req.body.itinerary;
        }
      }
      
      if (tourData.startLocation && typeof tourData.startLocation === 'string') {
        try {
          tourData.startLocation = JSON.parse(tourData.startLocation);
        } catch (e) {
          console.error('L·ªói khi parse startLocation:', e);
        }
      }
      
      if (tourData.guides && typeof tourData.guides === 'string') {
        try {
          tourData.guides = JSON.parse(tourData.guides);
        } catch (e) {
          console.error('L·ªói khi parse guides:', e);
        }
      }
      
      if (tourData.includes && typeof tourData.includes === 'string') {
        try {
          tourData.includes = JSON.parse(tourData.includes);
        } catch (e) {
          console.error('L·ªói khi parse includes:', e);
        }
      }
      
      if (tourData.excludes && typeof tourData.excludes === 'string') {
        try {
          tourData.excludes = JSON.parse(tourData.excludes);
        } catch (e) {
          console.error('L·ªói khi parse excludes:', e);
        }
      }
      
      if (tourData.startDates && typeof tourData.startDates === 'string') {
        try {
          tourData.startDates = JSON.parse(tourData.startDates);
        } catch (e) {
          console.error('L·ªói khi parse startDates:', e);
        }
      }

      // C·∫≠p nh·∫≠t tour
      const updatedTour = await Tour.findByIdAndUpdate(req.params.id, tourData, {
        new: true,
        runValidators: true
      });

      res.status(200).json({
        success: true,
        data: updatedTour
      });
    } catch (error) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t tour:', error);
      
      res.status(400).json({
        success: false,
        message: error.message
      });
    }
  });
};

/**
 * @desc    X√≥a tour
 * @route   DELETE /api/tours/:id
 * @access  Private/Admin
 */
exports.deleteTour = async (req, res, next) => {
  try {
    const tour = await Tour.findById(req.params.id);

    if (!tour) {
      return res.status(404).json({
        success: false,
        message: 'Kh√¥ng t√¨m th·∫•y tour'
      });
    }

    await tour.deleteOne();

    res.status(200).json({
      success: true,
      message: 'Tour ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng'
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y th·ªëng k√™ tour
 * @route   GET /api/tours/stats
 * @access  Private/Admin
 */
exports.getTourStats = async (req, res, next) => {
  try {
    const stats = await Tour.aggregate([
      {
        $match: { ratingsAverage: { $gte: 4 } }
      },
      {
        $group: {
          _id: { $toUpper: '$difficulty' },
          numTours: { $sum: 1 },
          numRatings: { $sum: '$ratingsQuantity' },
          avgRating: { $avg: '$ratingsAverage' },
          avgPrice: { $avg: '$price' },
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' }
        }
      },
      {
        $sort: { avgPrice: 1 }
      }
    ]);

    res.status(200).json({
      success: true,
      data: stats
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y top 5 tour gi√° r·∫ª
 * @route   GET /api/tours/top-5-cheap
 * @access  Public
 */
exports.getTop5CheapTours = async (req, res, next) => {
  try {
    const tours = await Tour.find()
      .sort('price -ratingsAverage')
      .limit(5);

    res.status(200).json({
      success: true,
      count: tours.length,
      data: tours
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y tour theo danh m·ª•c
 * @route   GET /api/tours/category/:category
 * @access  Public
 */
exports.getToursByCategory = async (req, res, next) => {
  try {
    const { category } = req.params;
    
    // T·∫°o regex ƒë·ªÉ t√¨m ki·∫øm c√°c tour c√≥ t·ª´ kh√≥a thu·ªôc danh m·ª•c
    // T√¨m ki·∫øm trong name, description, ho·∫∑c b·∫•t k·ª≥ tr∆∞·ªùng ph√π h·ª£p
    const query = {
      $or: [
        { name: { $regex: category, $options: 'i' } },
        { description: { $regex: category, $options: 'i' } },
        // C√≥ th·ªÉ th√™m tr∆∞·ªùng "category" v√†o model n·∫øu c·∫ßn
      ]
    };

    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    const tours = await Tour.find(query)
      .skip(skip)
      .limit(limit)
      .sort('-ratingsAverage');
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments(query);

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y tour theo ƒëi·ªÉm ƒë·∫øn
 * @route   GET /api/tours/destination/:destination
 * @access  Public
 */
exports.getToursByDestination = async (req, res, next) => {
  try {
    const { destination } = req.params;
    
    // T√¨m ki·∫øm tour v·ªõi ƒëi·ªÉm ƒë·∫øn c·ª• th·ªÉ
    // T√¨m tour c√≥ ƒëi·ªÉm ƒë·∫øn trong t√™n, m√¥ t·∫£ ho·∫∑c trong startLocation
    const query = {
      $or: [
        { name: { $regex: destination, $options: 'i' } },
        { description: { $regex: destination, $options: 'i' } },
        { 'startLocation.description': { $regex: destination, $options: 'i' } },
        { 'startLocation.address': { $regex: destination, $options: 'i' } }
      ]
    };

    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    const tours = await Tour.find(query)
      .skip(skip)
      .limit(limit)
      .sort('-ratingsAverage');
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments(query);

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y t·∫•t c·∫£ danh m·ª•c tour
 * @route   GET /api/tours/categories
 * @access  Public
 */
exports.getAllCategories = async (req, res, next) => {
  try {
    // Danh s√°ch c√°c danh m·ª•c
    const categories = [
      { id: '1', name: 'Bi·ªÉn', icon: 'umbrella-beach', color: '#03A9F4' },
      { id: '2', name: 'N√∫i', icon: 'mountains', color: '#8BC34A' },
      { id: '3', name: 'Th√†nh ph·ªë', icon: 'city', color: '#9C27B0' },
      { id: '4', name: 'L·ªãch s·ª≠', icon: 'landmark', color: '#FF9800' },
      { id: '5', name: '·∫®m th·ª±c', icon: 'utensils', color: '#F44336' },
      { id: '6', name: 'M·∫°o hi·ªÉm', icon: 'hiking', color: '#607D8B' },
    ];

    res.status(200).json({
      success: true,
      data: categories
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y t·∫•t c·∫£ ƒëi·ªÉm ƒë·∫øn ph·ªï bi·∫øn
 * @route   GET /api/tours/popular-destinations
 * @access  Public
 */
exports.getPopularDestinations = async (req, res, next) => {
  try {
    // S·ª≠ d·ª•ng aggregation ƒë·ªÉ ƒë·∫øm s·ªë l∆∞·ª£ng tour cho t·ª´ng ƒëi·ªÉm ƒë·∫øn
    const counts = await Tour.aggregate([
      {
        $match: { active: true } // Ch·ªâ ƒë·∫øm tour ƒëang active
      },
      {
        $group: {
          _id: '$startLocation.description',
          count: { $sum: 1 },
          image: { $first: '$imageCover' }
        }
      },
      {
        $sort: { count: -1 }
      },
      {
        $limit: 8
      }
    ]);

    // N·∫øu kh√¥ng ƒë·ªß d·ªØ li·ªáu t·ª´ DB, k·∫øt h·ª£p v·ªõi d·ªØ li·ªáu m·∫´u
    let destinations = counts.map((item, index) => ({
      id: index.toString(),
      name: item._id || 'ƒêi·ªÉm ƒë·∫øn',
      image: item.image || 'https://images.unsplash.com/photo-1570868738484-9fe36193da5b',
      color: getDestinationColor(index),
      tourCount: item.count
    }));

    // N·∫øu kh√¥ng ƒë·ªß 6 ƒëi·ªÉm ƒë·∫øn, b·ªï sung th√™m
    if (destinations.length < 6) {
      const sampleDestinations = [
        { id: '1', name: 'ƒê√† L·∫°t', image: 'https://images.unsplash.com/photo-1540308990836-9d27888d48e5', color: '#4CAF50', tourCount: 20 },
        { id: '2', name: 'Ph√∫ Qu·ªëc', image: 'https://images.unsplash.com/photo-1594380978175-7239bbfa6acb', color: '#2196F3', tourCount: 15 },
        { id: '3', name: 'H·∫° Long', image: 'https://images.unsplash.com/photo-1573165231839-7aa0a7d6198f', color: '#9C27B0', tourCount: 18 },
        { id: '4', name: 'Nha Trang', image: 'https://images.unsplash.com/photo-1570868738484-9fe36193da5b', color: '#FF9800', tourCount: 12 },
        { id: '5', name: 'H·ªôi An', image: 'https://images.unsplash.com/photo-1559592432-40e4760f4903', color: '#F44336', tourCount: 22 },
        { id: '6', name: 'Sapa', image: 'https://images.unsplash.com/photo-1562255355-06c922709729', color: '#607D8B', tourCount: 10 },
      ];

      // Th√™m c√°c ƒëi·ªÉm ƒë·∫øn m·∫´u n·∫øu ch∆∞a c√≥ trong k·∫øt qu·∫£ t·ª´ DB
      const existingNames = destinations.map(d => d.name.toLowerCase());
      const additionalDestinations = sampleDestinations.filter(
        d => !existingNames.includes(d.name.toLowerCase())
      );

      destinations = [...destinations, ...additionalDestinations.slice(0, 6 - destinations.length)];
    }

    res.status(200).json({
      success: true,
      data: destinations
    });
  } catch (error) {
    next(error);
  }
};

// H√†m ch·ªçn m√†u cho c√°c ƒëi·ªÉm ƒë·∫øn
function getDestinationColor(index) {
  const colors = ['#4CAF50', '#2196F3', '#9C27B0', '#FF9800', '#F44336', '#607D8B', '#795548', '#3F51B5'];
  return colors[index % colors.length];
}

/**
 * @desc    L·∫•y tour n·ªïi b·∫≠t (c√≥ rating cao)
 * @route   GET /api/tours/featured
 * @access  Public
 */
exports.getFeaturedTours = async (req, res, next) => {
  try {
    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    // L·∫•y tours n·ªïi b·∫≠t d·ª±a v√†o rating cao
    const tours = await Tour.find({ ratingsAverage: { $gte: 4.0 }, active: true })
      .sort('-ratingsAverage -ratingsQuantity')
      .skip(skip)
      .limit(limit);
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments({ ratingsAverage: { $gte: 4.0 }, active: true });

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y tour ph·ªï bi·∫øn nh·∫•t (nhi·ªÅu l∆∞·ª£t ƒë√°nh gi√°)
 * @route   GET /api/tours/popular
 * @access  Public
 */
exports.getPopularTours = async (req, res, next) => {
  try {
    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    // L·∫•y tours ph·ªï bi·∫øn d·ª±a v√†o s·ªë l∆∞·ª£ng ƒë√°nh gi√°
    const tours = await Tour.find({ active: true })
      .sort('-ratingsQuantity -ratingsAverage')
      .skip(skip)
      .limit(limit);
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments({ active: true });

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y tour m·ªõi nh·∫•t
 * @route   GET /api/tours/newest
 * @access  Public
 */
exports.getNewestTours = async (req, res, next) => {
  try {
    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    // L·∫•y tours m·ªõi nh·∫•t d·ª±a v√†o ng√†y t·∫°o
    const tours = await Tour.find({ active: true })
      .sort('-createdAt')
      .skip(skip)
      .limit(limit);
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments({ active: true });

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    L·∫•y tour gi√° r·∫ª
 * @route   GET /api/tours/budget
 * @access  Public
 */
exports.getBudgetTours = async (req, res, next) => {
  try {
    // Pagination
    const page = parseInt(req.query.page, 10) || 1;
    const limit = parseInt(req.query.limit, 10) || 10;
    const skip = (page - 1) * limit;
    
    // L·∫•y tours gi√° r·∫ª
    const tours = await Tour.find({ active: true })
      .sort('price -ratingsAverage')
      .skip(skip)
      .limit(limit);
    
    // ƒê·∫øm t·ªïng s·ªë l∆∞·ª£ng k·∫øt qu·∫£
    const total = await Tour.countDocuments({ active: true });

    res.status(200).json({
      success: true,
      data: {
        tours,
        pagination: {
          total,
          page,
          limit,
          pages: Math.ceil(total / limit)
        },
        totalCount: total
      }
    });
  } catch (error) {
    next(error);
  }
}; 